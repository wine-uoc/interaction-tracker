package com.example.positioningapp;

import android.os.Build;

import androidx.annotation.RequiresApi;

import java.nio.ByteBuffer;

public class QuuppaManufacturerData {

    private static final int AD_DATA_LENGTH = 24; //24 octets of manufacturer specific data (without considering COMPANY_ID)
    private static final byte[] COMPANY_ID = new byte[] {(byte)0x00, (byte)0xC7};
    private static final byte PACKET_ID = (byte) 0x01;
    private static final byte DEVICE_TYPE = (byte) 0x21; //Android Smartphone
    private static final byte HEADER = (byte) 0b00011010; //bits 8-7 -> RFU = 00; bits 6-5 -> Tag ID Type = 01 (generated by SW developer); bits 4-3 -> TX Power = 10 (~0dBm); bits 2-1 -> TX Rate = 10 (7-14Hz)
    private static final byte[] TAG_ID = new byte[] {(byte)0x11, (byte)0x22, (byte)0x33, (byte)0x44, (byte)0x55, (byte)0x66};// Tag ID = 0x112233445566
    private static final byte[] DF_FIELD = new byte[] {(byte)0x67, (byte)0xF7, (byte)0xDB, (byte)0x34, (byte)0xC4, (byte)0x03, (byte)0x8E,
                                                       (byte)0x5C, (byte)0x0B, (byte)0xAA, (byte)0x97, (byte)0x30, (byte)0x56, (byte)0xE6}; // DF field is fixed

    private static final byte CHECKSUM = (byte) 0xDA; //http://www.sunshine2k.de/coding/javascript/crc/crc_js.html

    public QuuppaManufacturerData (){}

    @RequiresApi(api = Build.VERSION_CODES.O)
    public int getCompanyId() {
        ByteBuffer wrapped = ByteBuffer.wrap(COMPANY_ID);
        short compId = wrapped.getShort();
        return (int) compId & 0xffff;
    }

    public byte[] toBytes(){
         byte[] result = new byte[AD_DATA_LENGTH];
         //System.arraycopy(COMPANY_ID, 0, result, 0, COMPANY_ID.length);
         result[0] = PACKET_ID;
         result[1] = DEVICE_TYPE;
         result[2] = HEADER;
         System.arraycopy(TAG_ID, 0, result, 3, TAG_ID.length);
         result[9] = CHECKSUM;
         System.arraycopy(DF_FIELD, 0, result, 10, DF_FIELD.length);
         return result;
    }

    /**
     * CRC calculation
     *
     * @param data The byte to crc check
     * @param crcInit The current crc result or another start value
     * @param poly The polynom
     * @return The crc result
     */
    private static byte compute_CRC8(byte data, byte crcInit, byte poly){
        byte crc;
        byte polynom;
        int i;

        crc = crcInit;
        for (i = 0; i < 8; i++) {

            if ((uint(crc) & 0x80) != 0) {
                polynom = poly;
            } else {
                polynom = (byte) 0;
            }

            crc = (byte) ((uint(crc) & ~0x80) << 1);
            if ((uint(data) & 0x80) != 0) {
                crc = (byte) (uint(crc) | 1);
            }

            crc = (byte) (uint(crc) ^ uint(polynom));
            data = (byte) (uint(data) << 1);
        }
        return crc;
    }

    /**
     * Convert to unsigned int
     *
     * @param v
     * @return
     */
    private static int uint(byte v) {
        return v & 0xFF;
    }


}
